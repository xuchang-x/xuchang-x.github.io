---
title: 深入理解Java虚拟机 阅读笔记
date: 2020-07-15 14:36:00
tags:
    - java
    - 虚拟机
description: description
---
# 第一章 走进Java
- 优点特性
    1. 一次编写，到处运行
    2. 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界
    3. 热点代码检测和运行时便衣及优化，虽运行时间增加而获得更高的性能 TODO
- Java虚拟机 目前常用的HotSpot

# 第二章 自动内存管理机制
## Java内存区域
![运行时数据区](深入理解Java虚拟机%20阅读笔记/运行时数据区.jpg)

1. 程序计数器：当前线程所执行字节码的行号指示器，记录的是正在执行的虚拟机字节码指令地址。每个线程都有一个独立的程序计数器。
2. 虚拟机栈区：Java方法执行的内存模型，也就是java在方法中调用方法的过程中使用栈这种结构记录方法调用路径。每个方法调用时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 TODO 动态链接是什么。
3. 本地方法栈：和虚拟机栈类似，区别在于这个方法栈中放的是Native方法。
4. 堆区：所有线程共享，用于存放对象实例。下边介绍一些堆区涉及到的技术：
    - 逃逸分析
        JVM判断新创建的对象是否逃逸的依据有：
            一、对象被赋值给堆中对象的字段和类的静态变量。对象被放进堆中，则其它线程就可以对其进行访问，所以对象的使用情况，编译器就无法再进行追踪。
            二、对象被传进了不确定的代码中去运行。VM在解析普通的字节码的时候，如果没有发生JIT即时编译，编译器是不能事先完整知道这段代码会对对象做什么操作。保守一点，这个时候也只能把对象是当作是逃逸来处理。
            如果满足了以上情况的任意一种，那这个对象JVM就会判定为逃逸。
        - `-XX:-DoEscapeAnalysis`关闭逃逸分析
    - 基于逃逸分析出现的技术
        - 栈上分配：如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率。
        - 同步消除：如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
            - `-XX:+EliminateLocks`开启同步消除
        - 标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
            - 标量：标量即不可被进一步分解的量，JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等）
            - 聚合量：标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。JAVA中对象就是可以被进一步分解的聚合量。
            - `-XX:+EliminateAllocations`开启标量替换
            - `-XX:+PrintEliminateAllocations`查看标量替换情况（Server VM 非Product版本支持）
5. 方法区（No-Heap）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
6. 运行时常量池：作为方法区的一部分储存
7. 直接内存（Direct Memory），并不是虚拟机运行时数据区一部分，也不是JVM中定义的内存区域。本机直接内存，不受Java对内存大小限制。

## 对象创建
1.检查： 检查指令参数能否在常量池中定位到一个类符号引用，该类是否已被加载、解析、初始化，若没有则先进行类加载。
2.内存分配：类加载后即可确定所需内存，内存分配
    - 内存规整的情况下可以使用指针碰撞方法，把指针向空闲方向挪动和对象大小相等的大小，多用于Serial,ParNew等带整理过程的收集器。
    - 内存零散的情况下使用空闲列表，即维护一个列表记录哪些内存块可用，多用于CMS这种基于标记清除的收集器。
    - 内存分配中的冲突处理：对象创建在虚拟机中是非常频繁的行为，仅修改一个指针所指向的位置在并发情况下也不是线程安全的。
        - 对内存分配操作加锁，使之变成同步过程。事实上虚拟机采用CAS加失败重试的方式保证更新操作原子性。
        - 本地线程分配缓冲（Thread Local Allocation Buffer , TLAB）先在堆中为每个线程分配一块区域，该线程TLAB用完之后再分配新的TLAB。
            - `-XX:+/-UseTLAB`设定是否开启TLAB
3. 初始化：内存分配完成后，虚拟机将除对象头外分配到的内存空间都初始化为零值，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。
       > TODO：多层级的 比如　`class A{List<Integer> a}` 不能及联的创建
> 到这里虚拟机认为对象已经创建好了，但JVM认为并未完成
4. <init>方法 把对象按照程序员的意愿进行初始化，为对象赋值。

---
对象内存布局
1. 对象头（MarkWord），包含两部分数据：
    - 对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
    ![hotspot对象头](深入理解Java虚拟机%20阅读笔记/hotspot对象头.jpg)
    - 类型指针，指向类的元类型数据。（并不是所有虚拟机实现都必须在对象数据上保留类型指针）
    - 如果是数组，还会记录数组长度
2. 实例数据
    在程序代码中所定义的各种类型的字段内容。虚拟机分配策略默认相同宽度的字段分配到一起，longs/doubles、ints、shorts/chars、 bytes/booleans、oops（Ordinary Object Pointers）
3. 对齐填充
    占位符，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头部分正好是8字节的倍数。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
---
对象访问定位

句柄
![句柄访问对象](source/_posts/深入理解Java虚拟机 阅读笔记/句柄访问对象.jpg)
直接指针 速度更快，节省了一次指针定位的时间开销 (Hotspot 使用这种)
![直接指针访问](source/_posts/深入理解Java虚拟机 阅读笔记/直接指针访问.jpg)

堆内存溢出OutOfMemory
内存泄漏    内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
内存溢出    内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

栈内存溢出 StackOverFlow

操作系统分配给每个进程的内存是有限制的，譬如32位的Windows 限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内 存为2GB(操作系统限制)减去Xmx(最大堆容量)，再减去MaxPermSize(最大方法区容 量)，程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在 内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以 建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等

当前的很多主流框架，如Spring、Hibernate，在对类进行增强时， 都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class可以加载入内存。

Unsafe实例进行内存分配(Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回 实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能)。因为，虽然使用 DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申 请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方 法是unsafe.allocateMemory()。

# 第三章 垃圾收集器&内存分配策略

## 回收策略
1. 引用计数法：问题，循环引用的无法回收 a->b b->a

2. 可达性分析：GC Root做为起始点，找引用链
![引用链](深入理解Java虚拟机%20阅读笔记/引用链.jpg)
    - 虚拟机栈(栈帧中的本地变量表)中引用的对象。
    - 方法区中类静态属性引用的对象。
    - 方法区中常量引用的对象。
    - 本地方法栈中JNI(即一般说的Native方法)引用的对象。
    
强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。
强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引 用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将 要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实 现软引用。
弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的 对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引 用。
虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引 用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一 个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2之后，提供了PhantomReference类来实现虚引用。

要经历两次标记过程:如果对象在进行可达 性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或 者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做 F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行 它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做 的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情 况)，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统 崩溃。

---
## 方法区回收

hotspot中永久代==方法区
老年代+年轻代==堆区

永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。

判断常量废弃->没有引用

类需要同时满足下面3个条件才能算是“无用的类”:
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。 TODO
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该 类的方法。

---
## 垃圾回收算法
1. 标记清除(要是能找到代码就更好了)
![标记清除](深入理解Java虚拟机%20阅读笔记/标记清除.jpg)
它的主要不足有两个:
一个是效率问题，标记和清除两个过程的效率都不高;
另一个是 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程 序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾 收集动作。
2. 复制算法
![复制算法](深入理解Java虚拟机%20阅读笔记/复制算法.jpg)
实现简单，运行高效。只是这种算法的代价是将内存缩小为了原 来的一半，未免太高了一点

HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，
也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，
只有10% 的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，
我们没有办法保证每 次回收都只有不多于10%的对象存活，当Survivor空间不够用时，
需要依赖其他内存(这里 指老年代)进行分配担保(Handle Promotion)。

内存的分配担保也 一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时， 这些对象将直接通过分配担保机制进入老年代。

3. 标记整理
![标记整理](深入理解Java虚拟机%20阅读笔记/标记整理.jpg)
复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的 是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中 所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

4. 分代收集
当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算 法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

HotSpot算法实现
1. 枚举根节点
从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在 全局性的引用（例如常量或类静态属性）与执行上下文(例如栈帧中的本地变量表)中，在很多应用仅方法区就有数百兆，如果要逐个检查这里面的引用必然会消耗很多时间。
HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，类加载完成时HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。
> 所以JIT是啥

2. 安全点

在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来:可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在"特定的位置"记录了这些信息，这些位置称为安全点(Safepoint)，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

安全点的选定基本上是以程序"是否具有让程序长时间执行的特征"为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，"长时间执行"最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。
TODO没看懂
- 抢先式中断：抢先式中断不需 要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程 中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采 用抢先式中断来暂停线程从而响应GC事件。
- 主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设 置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。下面代码清 单3-4中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存 页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号
- 现在基本没有使用抢先式中断的。

3. 安全区域
Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是， 程序“不执行”的时候呢?所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处 于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去 中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全 区域(Safe Region)来解决。
安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方 开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当 在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离 开Safe Region时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程)，如果完 成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为 止。
> TODO 所以safe region是 线程没抢到cpu时候就标记自己进入了safe region？

---
## 垃圾收集器
![可使用的垃圾回收器及搭配关系](深入理解Java虚拟机%20阅读笔记/可使用的垃圾回收器及搭配关系.jpg)
1. Serial收集器
- 复制算法
![Serial收集器](深入理解Java虚拟机%20阅读笔记/Serial收集器.jpg)
进行垃圾收集时，必须暂停其他所有的工作线程 Stop The World
- JVM client模式下年轻代默认收集器
> 看下JVM client模式和Server模式
- 与其他收集器的单线程比 简单搞笑
- 限定单CPU环境下，没有线程交互，提高效率

2. ParNew
![ParNew](深入理解Java虚拟机%20阅读笔记/ParNew.jpg)
- Server 模式下默认的年轻代垃圾回收器，因为除了Serial，只有ParNew可以与CMS搭配使用。
并发（Concurrent）&并行（Parallel）
![并发&并行](深入理解Java虚拟机%20阅读笔记/并发&并行.jpg)
对垃圾回收来说
并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状 态。
并发：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能 会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
- -XX:ParallelGCThreads 限制垃圾收集线程数
- 使用-XX:+UseConcMarkSweepGC 后的默认新生代收集器
- 复制算法

3. Parallel Scavenge
- 使用复制算法，并行多线程收集器
- Parallel Scavenge关注吞吐量而非尽可能缩短垃圾收集时用户线程停顿时间。CPU用于运行用户代码的时间与CPU总 消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚 拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高 吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不 需要太多交互的任务。

- Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集 停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参 数。
- MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回 收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使 得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取 的:系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾 收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每 次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。。

- -XX:+UseAdaptiveSizePolicy 这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、 Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX: PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信 息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC 自适应的调节策略(GC Ergonomics)

4. Serial Old
- Serial收集器的老年代版本
- “标记-整 理”算法
- 主要意义也是在于给Client模式下的虚拟机使用
- Server模式 下，那么它主要还有两大用途:一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用[1]，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用
> CMS Concurrent Mode Failure

![Serial Old](深入理解Java虚拟机%20阅读笔记/Serial%20Old.jpg)

5. Parallel Old
- Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法
![Parallel Old](深入理解Java虚拟机%20阅读笔记/Parallel%20Old.jpg)

- 直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组 合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old 收集器。

6. CMS收集器（Concurrent Mark Sweep）
- 以获取最短回收停顿时间为目标的收集器
- 重 视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验
- 步骤 初始标记(CMS initial mark) -> 并发标记(CMS concurrent mark) - 重新标记(CMS remark) - 并发清除(CMS concurrent sweep)
- 初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是 标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远 比并发标记的时间短。
![Parallel Old](深入理解Java虚拟机%20阅读笔记/CMS.jpg)
> 为什么初始标记不用多线程
> 重置线程是个什么操作

- 缺点
    - CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。 在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程(或者说CPU资 源)而导致应用程序变慢，总吞吐量会降低。
    - CMS默认启动的回收线程数是(CPU数量 +3)/4 也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。
        - 虚拟机提供了一种称为“增量式并发收集器”(Incremental Concurrent Mark Sweep/i-CMS)的 CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思 想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的 独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些， 也就是速度下降没有那么明显。实践证明，增量时的CMS收集器效果很一般，在目前版本 中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。
    - CMS收集器无法处理浮动垃圾(Floating Garbage)，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴 随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法 在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃 圾”。
        - 由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间 给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进 行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置 下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在 应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来 提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器 的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一 次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案:临时启用Serial Old收集器来 重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CM SInitiatingOccupancyFraction设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能 反而降低。
        - -XX:CMSInitiatingOccupancyFraction：CMS中触发full gc的老年代比例
    - CMS是一款基于“标记—清除”算法实现的收集 器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会有大量 空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有 很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。
        - -XX:+UseCMSCompactAtFullCollection：默认开启，开启在CMS收集器顶不住要进行FullGC时开启内存碎片的合并 整理过程
        - 内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。 虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于 设置执行多少次不压缩的Full GC后，跟着来一次带压缩的(默认值为0，表示每次进入Full GC时都进行碎片整理)。
7. G1(Garbage-First)收集器
- 面向服务端应用的垃圾收集器
- 优势：
    - 并行与并发:G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU(CPU或者 CPU核心)来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的 GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
    - 分代收集:与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其 他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已 经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
        - 整个Java堆划分 为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和 老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合。
    - 空间整合:与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实 现的收集器，从局部(两个Region之间)上来看是基于“复制”算法实现的，但无论如何，这 两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种 特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一 次GC。
    - 可预测的停顿:这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关 注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一 个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实 时Java(RTSJ)的垃圾收集器的特征了。
        - G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的 空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时 间，优先回收价值最大的Region(这也就是Garbage-First名称的来由)。这种使用Region划分 内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高 的收集效率。
- 问题和处理
    - Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其 他对象引用，而是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定确定对象 是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性?这个问题其实并非在G1中才 有，只是在G1中更加突出而已。在以前的分代收集中，新生代的规模一般都比老年代要小许 多，新生代的收集也比老年代要频繁许多，那回收新生代中的对象时也面临相同的问题，如 果回收新生代时也不得不同时扫描老年代的话，那么Minor GC的效率可能下降不少。
      在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象 引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对 应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个 Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中(在分代 的例子中就是检查是否老年代中的对象引用了新生代中的对象)，如果是，便通过 CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内 存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗 漏。
![G1](深入理解Java虚拟机%20阅读笔记/G1.jpg)
> 《Garbage-First Garbage Collection》论文

- -XX:MaxGCPauseMillis=50 GC最大停顿时间

## GC日志
![GC日志](深入理解Java虚拟机%20阅读笔记/GC日志1.jpg)
- 每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日 志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定 的共性
- 最前面的数字“33.125:”和“100.667:”代表了GC发生的时间，这个数字的含义是从Java 虚拟机启动以来经过的秒数。
- GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新 生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。
    - 新生代收集器ParNew的日志也会出现“[Full GC”(这一般是因为出现了分配担保失败之 类的问题，所以才导致STW)。
- “[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与 使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变 为“[ParNew”，意为“Parallel New Generation”。
- 方括号内部的“3324K->152K(3712K)”含义是“GC前该内存区域已使用容量-> GC后该内存区域已使用容量(该内存区域总容量)”。而在方括号之外的“3324K-> 152K(11904K)”表示“GC前Java堆已使用容量->GC后Java堆已使用容量(Java堆总容 量)”。
- “0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。
    - 有的收集器会 给出更具体的时间数据，如“[Times:user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、 sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核 态消耗的CPU事件和操作从开始到结束所经过的墙钟时间(Wall Clock Time)
    - CPU时间与 墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻 塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些 CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

## 内存分配与回收策略
- Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题:给对 象分配内存以及回收分配给对象的内存。